# Smooth Car Path Traversal and Animation in Grid Maps

This Python project demonstrates a system for generating a smooth traversal path for a car-like robot in a 2D grid map. It includes pathfinding using a turn-prioritized Depth-First Search (DFS), path smoothing using B-splines, collision detection for a rectangular car model, and visualization of the car's movement as an MP4 or GIF animation.

![Demo Animation Placeholder](placeholder_animation.gif)
*(Replace `placeholder_animation.gif` with an actual GIF generated by the script, e.g., `smooth_car_progress.gif` if you save it as GIF)*

## Features

*   **Grid Map Representation:** Uses a simple 2D NumPy array for the map (0 for empty, 1 for obstacle).
*   **Pathfinding:** Implements a Depth-First Search (DFS) variant that prioritizes turning maneuvers to explore more of the available space.
*   **Path Smoothing:** Utilizes SciPy's B-spline interpolation (`splprep`, `splev`) to create smooth trajectories from the raw grid control points.
*   **Kinematic Car Model:** Represents the car as a rectangle with definable length and width.
*   **Collision Detection:**
    *   Checks if the car (at a given pose: x, y, angle) collides with obstacles in the grid map.
    *   Validates the entire smoothed path for collisions and highlights collided segments in the animation.
*   **Visualization:**
    *   Uses Matplotlib to display the grid map, the planned path, and the car.
    *   Animates the car traversing the smoothed path.
    *   Shows the car changing color (e.g., to orange) if it enters a pre-detected collision state.
    *   Displays the start point on the grid.
    *   Chinese characters and negative signs are correctly displayed in plots.
*   **Animation Export:**
    *   Saves the animation as an MP4 video file using `ffmpeg`.
    *   Provides a progress callback during MP4 saving, printing updates to the console.
    *   Includes a fallback to save as a GIF using `Pillow` if MP4 saving fails.
    *   Saves a static image if the path is too short for animation or if path generation fails.
*   **Customizable Parameters:**
    *   Car dimensions (length, width).
    *   Spline smoothness.
    *   Number of points per segment in the smoothed path.
    *   Animation frame interval.

## Prerequisites

*   Python 3.x
*   NumPy
*   Matplotlib
*   SciPy
*   **FFmpeg:** Required for saving animations as MP4.
    *   On Debian/Ubuntu: `sudo apt-get install ffmpeg`
    *   On macOS (using Homebrew): `brew install ffmpeg`
    *   On Windows: Download from [ffmpeg.org](https://ffmpeg.org/download.html) and add to your system's PATH.
*   **Pillow:** Required for saving animations as GIF (used as a fallback).
    *   `pip install Pillow`

## Installation

1.  **Clone the repository:**
    ```bash
    git clone <your-repository-url>
    cd <your-repository-name>
    ```

2.  **Install Python dependencies:**
    ```bash
    pip install numpy matplotlib scipy Pillow
    ```
    (Ensure FFmpeg is installed separately as per the Prerequisites section).

## How to Run

The main script can be executed directly. Configuration for the map, start position, and car parameters is done within the `if __name__ == '__main__':` block of the Python script.

1.  **Modify Parameters (Optional):**
    Open the Python script (`your_script_name.py`) and adjust the following in the `if __name__ == '__main__':` block if needed:
    *   `grid_map_for_smooth`: Define your grid map.
    *   `start_pos_grid_smooth`: Set the starting `(row, column)` for the car.
    *   `SmoothCurveCarTraversal` constructor parameters:
        *   `car_length`
        *   `car_width`
        *   `spline_smoothness`
        *   `points_per_segment`
    *   `traversal_system.visualize` parameters:
        *   `filename`: Output animation file name.
        *   `interval`: Animation frame interval in milliseconds.

2.  **Run the script:**
    ```bash
    python your_script_name.py
    ```

## Output

*   **Animation File:** An `.mp4` (or `.gif` if MP4 fails) file (e.g., `smooth_car_progress.mp4`) will be saved in the same directory, showing the car traversing the path.
*   **Static Image:** If the path is too short or invalid, a static `.png` image (e.g., `smooth_car_progress_static.png` or `smooth_car_progress_static_fallback.png`) will be saved.
*   **Console Output:**
    *   Status messages about path generation and collision validation.
    *   Progress updates during animation saving (e.g., "Saving animation progress: X%").
    *   Error messages, if any.

## Code Structure Overview

*   **`SmoothCurveCarTraversal` Class:**
    *   `__init__(...)`: Initializes the map, car, pathfinding, and smoothing.
    *   `_generate_grid_control_points(...)`: DFS-based raw path generation.
    *   `_simplify_and_convert_control_points(...)`: Simplifies the raw path.
    *   `_create_smooth_path_from_waypoints(...)`: Uses B-splines for path smoothing.
    *   `_validate_smooth_path_for_collision()`: Checks the entire smoothed path for collisions.
    *   `visualize(...)`: Handles Matplotlib animation setup and saving.
    *   `_visualize_static_obstacle_start(...)`: Fallback for static image generation.
    *   `_is_grid_valid(...)`, `_get_turn_prioritized_grid_moves(...)`: Helper methods for DFS.
*   **Collision Detection Functions:**
    *   `get_car_corners(...)`: Calculates the world coordinates of the car's corners.
    *   `check_car_collision_at_pose(...)`: Checks for collision between the car and grid obstacles at a specific pose.
*   **`SaveProgressCallback` Class:**
    *   A helper class passed to `FuncAnimation.save` to provide console feedback on saving progress.
*   **Constants & Setup:**
    *   Matplotlib configuration for Chinese fonts and visual style.
    *   Grid cell type constants (EMPTY, OBSTACLE, START_POINT_GRID).
*   **`if __name__ == '__main__':` block:**
    *   Example usage: Defines a sample grid map and start position, instantiates `SmoothCurveCarTraversal`, and calls `visualize()`.

## Potential Enhancements

*   Implement more advanced pathfinding algorithms (A*, RRT*, etc.).
*   Incorporate car dynamics and control constraints.
*   Allow for dynamic obstacles.
*   Interactive map definition or loading from a file.
*   More sophisticated collision checking (e.g., Separating Axis Theorem for polygon-polygon).

## License

(Specify your license here, e.g., MIT License. If you don't have one, consider adding one. A common simple one is MIT.)
